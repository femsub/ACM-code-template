QuickHull

#include <iostream>
#include <math.h>
#define maxn 100000
#define zero 1e-12
#define sgn(x) (fabs(x)<zero?0:(x>0?1:-1))
#define cross(a,b,c) ((b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x))
#define cmp(a,b) (a.x<b.x || sgn(a.x-b.x)==0 && a.y<b.y)

using namespace std;
struct point{
    double x,y;
}p[maxn];
double s[maxn];

void hull(int l,int r,point a,point b){
    int x=l,i=l-1,j=r+1,k;
    for (k=l;k<=r;k++){
        double temp=sgn(s[x]-s[k]);
        if (temp<0 || temp==0 && cmp(p[x],p[k])) x=k;
    }
    point y=p[x];
    for (k=l;k<=r;k++){
        s[++i]=cross(p[k],a,y);
        if (sgn(s[i])>0) swap(p[i],p[k]); else i--;
    }
    for (k=r;k>=l;k--){
        s[--j]=cross(p[k],y,b);
        if (sgn(s[j])>0) swap(p[j],p[k]); else j++;
    }
    if (l<=i) hull(l,i,a,y);
    printf("%.4lf %.4lf\n",y.x,y.y);
    if (j<=r) hull(j,r,y,b);
}

int main(){
    freopen("CH2D.in","r",stdin);
    freopen("CH2D1.out","w",stdout);
    int n,i,x=0;
    scanf("%d",&n);
    for (i=1;i<=n;i++){
        scanf("%lf %lf",&p[i].x,&p[i].y);
        if (x==0 || cmp(p[i],p[x])) x=i;
    }
    swap(p[1],p[x]);
    printf("%.4lf %.4lf\n",p[1].x,p[1].y);
    hull(2,n,p[1],p[1]);
    return 0;
}


********************************************

struct point{
        double x,y;
        point(){x=y=0;}
        point(double x,double y){this->x=x;this->y=y;}
        point operator*(const double &a){return point(a*x,a*y);}
        point operator/(const double &a){return point(x/a,y/a);}
        double operator*(const point &a){return a.x*x+a.y*y;}
        point operator+(const point &a){return point(x+a.x,y+a.y);}
        point operator-(const point &a){return point(x-a.x,y-a.y);}
        bool operator<(const point &a)const{return x<a.x-esp||(abs(x-a.x)<esp&&y<a.y-esp);}
};
point operator*(double const &a,point const &b){return point(a*b.x,a*b.y);}
double cross(point a,point b){return a.x*b.y-a.y*b.x;}
double leng(point a){return sqrt(a.x*a.x+a.y*a.y);}
vector<point>in,out;
void convex()
{
    sort(all(in));
    int k=0,n=in.size();
    out.clear();
    if(!n)return;
    out.resize(2*n);
    for(int i=0;i<n;i++){                                                   //开始和最后一个肯定是
        while(k>1&&cross(out[k-1]-out[k-2],in[i]-out[k-1])<esp)k--;
        out[k++]=in[i];
    }
    for(int i=n-2,t=k;i>=0;i--){
        while(k>t&&cross(out[k-1]-out[k-2],in[i]-out[k-1])<esp)k--;
        out[k++]=in[i];
    }
    if(k>=2)
        out.resize(k-1);
    return;
}


