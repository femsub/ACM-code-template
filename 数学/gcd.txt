
*******************************
inline int gcd(int a,int b){while(b^=a^=b^=a%=b);return a;}

*****************************
LL lcm = 1;
	for(LL i = 1; i <= n; i++)lcm = lcm/__gcd(lcm,m[i])*m[i];

***************	O(n)预处理 O(1)查询
const int N=10000000;
const int sn=sqrt(N);
bool np[N+5];
int ps[N/10+5],pn=0;       //N>65000时素数少于n/10
int cs[N+5][3];
void xs()
{
    np[1]=cs[1][0]=cs[1][1]=cs[1][2]=1;
    int tp;
    for(int i=2;i<=N;i++)
    {
        if(!np[i]) {cs[i][0]=cs[i][1]=1; cs[i][2]=i; ps[++pn]=i;}
        for(int j=1;j<=pn&&i*ps[j]<=N;j++)
        {
            tp=i*ps[j];
            np[tp]=1;
            cs[tp][0]=cs[i][0]*ps[j];
            cs[tp][1]=cs[i][1];
            cs[tp][2]=cs[i][2];
            if(cs[tp][0]>cs[tp][1])swap(cs[tp][0],cs[tp][1]);
            if(cs[tp][1]>cs[tp][2])swap(cs[tp][1],cs[tp][2]);
            if(i%ps[j]);else break;
        }
    }
}
int gcdd[sn+3][sn+3];
void smgcd()
{
    for(int i=0;i<=sn;i++)
        gcdd[i][0]=gcdd[0][i]=i;
    for(int i=1;i<=sn;i++)
        for(int j=1;j<=i;j++)
            gcdd[i][j]=gcdd[j][i]=gcdd[i-j][j];
}
void pre_gcd() {xs(); smgcd();}
int gcd(int a,int b)
{
    if(a<=sn&&b<=sn)return gcdd[a][b];
    int *x=cs[a],g=1,d;
    for(int i=0;i<3;i++)
    {              
        if(x[i]<=sn) d=gcdd[x[i]][b%x[i]];
        else if(b%x[i]) d=1;
        else d=x[i];        
        g*=d; b/=d;
    }
    return g;
}